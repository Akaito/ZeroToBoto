---
category: info
info_order: 4
date: 2017-06-28 15:00 -07:00
title: Hangman
---

```python
Word so far: _ t t _ _ 
Guesses so far: ['t', 'a']
Guess a letter: e
 
Word so far: _ t t e _ 
Guesses so far: ['t', 'a', 'e']
Guess a letter: 
```

<!-- more -->

<!-- Template stuff: https://jekyllrb.com/docs/includes/ -->

In almost any use of programming, dealing with collections of an arbitrary number of things is much more interesting and useful than dealing with single pre-determined variables.
Performing some repetitive task quickly is, after all, one of the main reasons to write any code at all.
Python has a few "[sequence types](https://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange)", also often called "collections".
We'll be mostly talking about lists, since they're one of the most generally useful (least specialized), and very commonly seen.
Python also has particularly handy syntax for dealing with lists that many other languages don't come pre-built with.

```python
>>> mascots = ['Sonic', 'Mario', 'Crash']
>>> mascots
['Sonic', 'Mario', 'Crash']
>>> 'Bubsy' in mascots
False
>>> for mascot in mascots:
...     print mascot
...
Sonic
Mario
Crash
```

Lists are declared with square brackets.
`[` begins a list, and `]` ends it.
Each item within a list is separated by a comma `,`.
You can declare empty lists (`[]`).
Lists are also <em>heterogenous</em>, as opposed to their cousin in most statically-typed languages, arrays, which are <em>homogenous</em> (Python is a dynamically typed language).
This means you can store strings, numbers, etc. together in a single list.

Python provides some niceties like "item in sequence" to test for the presence of something.
Also "for item in sequence:" to enumerate/iterate over each item individually.

```python
>>> len(mascots)
3
>>> mascots[0]
Sonic
>>> mascots[2]
Crash
>>> mascots[3]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>> mascots.append('Kirby')
>>> mascots[3]
Kirby
```

You can ask Python for the length (<tt>len()</tt>) of a sequence.
This is the number of items it contains, and doesn't care how "big" each item is individually.

"Indexing" a sequence is how you get a single item out of it by using that item's offset from the first item (the "head" of the sequence).
So the first item is at offset/index 0, the next is 1, and so on.
This "offset from the head" is why counting in programming starts from 0 instead of 1 in most cases.
The "why" of it makes more sense when you're doing pointer-based work with a language like C++, and it will take some getting used to.
It's a very good habit to have to make it easier to move to other languages later.
Though we won't be needing it much for the hangman game.

As shown above, you can also add items to a list by <em>appending</em> them onto it.

```python
>>> message = 'Hi there'
>>> 'there' in message:
True
>>> for letter in message:
...     print letter
...
H
i
 
t
h
e
r
e
>>> message.append('!')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'str' object has no attribute 'append'
>>> message = message + '!'
>>> print message
Hi there!
```

Strings, being another sequence type (like lists), allow many of the same operations.

Though, <tt>str</tt> is an "immutable" sequence type, while <tt>list</tt> is a "mutable" sequence type.
This is part of why you can't directly append to an existing string, and instead have to create a new string and assign it the same name to simulate that.
That's a whole other topic, which you can read a little about [here](https://stackoverflow.com/questions/4677529/chart-of-mutable-versus-immutable-types).
For now, just know that you may have to player around with "foo = foo + bar" versus "foo.append(bar)" for a bit, until you get used to it.

---

## Exercise: Getting started

A hangman game needs to print out the target word with some letters revealed or still hidden.
Since that's something the game will need to do more than once (as letters are found), write a small function that returns the word with letters hidden or revealed.
Hidden letters will be represented by a period.

```python
chris@CSU:~/work/ZeroToBoto$ python assets/hangman-0.py 
Word so far: otter
Word so far: .....
```

Your function should look, and be used, like the below example.  We'll worry about individually revealed letters later.

```python
def partial_word(word, revealed):
    # your code here

target_word = 'otter'
print partial_word(target_word, True)
print partial_word(target_word, False)
```


### Hints

<ol>
{% include spoiler-hint.html major=0 minor=1
    summary="Per-letter behavior"
    details="
        You want to do something <code>for each_letter in the_word</code>.
" %}
{% include spoiler-hint.html major=0 minor=2
    summary="Building a temporary word"
    details="
        In your function, declare a new <code>partial=''</code>, and append each letter to it.  This will make it easier later to append either a revealed or a shown letter.
" %}
</ol>

[The completed example.]({{ site.baseurl }}{% link /assets/hangman-0.py %})

---

[The complete hangman.]({{ site.baseurl }}{% link /assets/hangman-complete.py %})

---

## Extra credit

1. Read up on, and play around with, [slicing lists](https://stackoverflow.com/questions/509211/explain-slice-notation#509295).

